{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Audio-Matrix","text":"<p>The Audio Matrix is a configurable router and signal processor for Audio-Setups with lots of channels/speakers that offers built in remote control via OSC.</p> <p>It runs as a JACK client.</p> <p>A configurable amount of input tracks is routed in parallel through user configurable tracks, that can process the audio on them using a variety of modules.</p> <p>An example Procesing setup could look like this: </p>"},{"location":"#licenses","title":"Licenses","text":"<p>This Project is licensed under the GPLv3.</p> <p>Calculation of the IIR filter coefficients is performed using the IIR library by Exstrom Laboratories, also licensed under the GPLv3</p> <p>AudioBuffer and RingBuffer implementations are taken from the anira library, licensed under Apache License 2.0</p>"},{"location":"configuration/","title":"Configuration","text":"<p>Configuration is done using a config file in YAML format. Some example configs can be found in <code>examples/configs</code>.</p>"},{"location":"configuration/#general-configuration","title":"General Configuration:","text":"Option Name Description Default Value <code>port</code> Port the OSC-Server listens on <code>12345</code> <code>n_input_channels</code> Amount of Input channels to be created. these are sent to every track <code>64</code> <code>tracks</code> Array of <code>tracks</code>, see \"Configuration of Tracks\" <code>[]</code>"},{"location":"configuration/#configuration-of-tracks","title":"Configuration of Tracks:","text":"Option Name Description Default Value <code>name</code> Name of this track <code>\"\"</code> <code>modules</code> Array of <code>modules</code>, see \"Configuration of Modules\" <code>[]</code>"},{"location":"configuration/#configuration-of-modules","title":"Configuration of Modules:","text":"<p>Modules always start with the name of the module as the outermost key. The module names and module specific options can be found here.</p> <p>For simple modules that don't take any parameters like <code>sum</code> only the name is needed, you could specify it as</p> <pre><code>tracks:\n  - name: example track\n    modules:\n      - sum\n</code></pre> <p>for more complex modules additional options are needed. If the module should be OSC-controllable, the option <code>osc_path</code> is required. it expects as a string the osc path this module should listen to. complex modules might use this path as a base path to listen on different subpaths, see their individual configs for that.</p> <p>Some options called \"primary options\" can be directly set as the value of a module type, for example</p> <pre><code>tracks:\n  - name: example track\n    modules:\n      - gain: 0.5\n</code></pre> <p>This only works if this is the only option that is manually set.</p> <p>In all other cases modules are defined using more key-value-pairs:</p> <pre><code>tracks:\n  - name: example track\n    modules:\n      - hoa_encoder:\n          order: 3\n          osc_path: /positions\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#building-from-source","title":"Building from source","text":"<pre><code>cmake -DCMAKE_BUILD_TYPE=Debug -B ./build -G Ninja\ncmake --build ./build --config Debug --target all\n</code></pre>"},{"location":"modules/","title":"Modules","text":""},{"location":"modules/#module-gain","title":"Module: Gain","text":"name <code>gain</code> OSC controllable yes OSC format <code>[osc_path] if &lt;channel_index&gt; &lt;channel_gain&gt;</code> <p>Module used to apply individual gains per channel. OSC control enables the setting of these gains.</p> Option Name Description Default Value <code>factor</code> (primary option) Initial gain for all channels <code>1</code>"},{"location":"modules/#module-ambisonics-encoder","title":"Module: Ambisonics Encoder","text":"name <code>hoa_encoder</code> OSC controllable yes OSC format <code>[osc_path] ifff &lt;channel_index&gt; &lt;azimuth_in_rad&gt; &lt;elevation_in_rad&gt; &lt;distance_in_m&gt;</code> <p>This module encodes the incoming audio into the ambisonics domain. channels are ordered following the AmbiX format. The individual positions for each channel are settable using OSC.</p> Option Name Description Default Value <code>order</code> Ambisonics order to encode to, currently orders up to 4 are supported <code>3</code>"},{"location":"modules/#module-sum","title":"Module: Sum","text":"name <code>sum</code> OSC controllable no <p>This module sums up all incoming channels into one channel</p>"},{"location":"modules/#module-filter","title":"Module: Filter","text":"name <code>filter</code> OSC controllable no <p>This module implements Linkwitz-Riley lowpass- or highpass filters.</p> Option Name Description Default Value <code>order</code> Order of the Linkwitz-Riley Filter, order of the individual butterworth filters will be <code>order/2</code> <code>4</code> <code>freq</code> Cutoff Frequency of the Filter (in Hz) <code>150</code> <code>type</code> Filter type, options are <code>LP</code> and <code>HP</code> <code>HP</code>"},{"location":"modules/#module-distance-gain","title":"Module: Distance Gain","text":"name <code>distance_gain</code> OSC controllable yes OSC format <code>[osc_path] if &lt;channel_index&gt; &lt;distance_in_m&gt;</code> <p>This Module adjusts the gain of a channel depending on its distance from the listener</p>"},{"location":"modules/#module-delay","title":"Module: Delay","text":"name <code>delay</code> OSC controllable no <p>Simple non-interpolating delay line to adjust for latencies between different playback systems</p> Option Name Description Default Value <code>time</code> (primary option) Delay time in ms <code>5</code>"},{"location":"Development/adding_modules/","title":"Adding a new module","text":"<p>To add a module, several files have to be edited, until a more streamlined approach is found.</p>"},{"location":"Development/adding_modules/#1-add-identifier-of-module-to-modules-enum","title":"1. Add identifier of Module to Modules enum","text":"<p>In <code>ModuleConfig.h</code> add an identifier of your module to the <code>Modules</code> enum</p>"},{"location":"Development/adding_modules/#2-create-module-files","title":"2. Create Module Files","text":"<p>Modules must inherit from <code>Module</code>.</p> <p>Modules need a config struct inheriting from <code>ModuleConfig</code>.</p> <p>Modules should be created in a subfolder of Module following this directory structure:</p> <pre><code>source\n\u2514\u2500\u2500 Module\n    \u251c\u2500\u2500 MyModule\n    \u2502   \u251c\u2500\u2500 MyModuleConfig.h\n    \u2502   \u251c\u2500\u2500 MyModule.cpp\n    \u2502   \u2514\u2500\u2500 MyModule.h\n    \u251c\u2500\u2500 ModuleConfig.h\n    \u251c\u2500\u2500 Module.cpp\n    \u2514\u2500\u2500 Module.h\n</code></pre> <ol> <li>Create your classes</li> </ol> <p>TODO explain classes</p>"},{"location":"Development/adding_modules/#3-parsing-of-module-config","title":"3. Parsing of Module Config","text":"<p>Parsing of the config happens in the <code>ConfigParser</code>, so we need to add the module-specific config parser there.</p> <p>Add an include directive for your config in <code>ConfigParser.h</code>:</p> <pre><code>#include &lt;MyModuleConfig.h&gt;\n</code></pre> <p>Add a function signature for the parser function to <code>ConfigParser.h</code>, next to the other similar functions:</p> <pre><code>ModuleConfigPtr parse_module_mymodule(YAML::Node module);\n</code></pre> <p>Implement this function in <code>ConfigParser.cpp</code>. Parsing is done using the yaml-cpp library. For simple key/value pairs in the config you can use the <code>get_config_option()</code> function for convenience. If your Module is controlled using OSC, call <code>parse_module_osc_params()</code> for your module.</p> <p>The call to <code>parse_module_mymodule</code> should happen in <code>ConfigParser::parse_module()</code>, so you have to add an if-case for your module to the case structure there:</p> <pre><code>} else if (name == \"mymodule\") {\n    return parse_module_mymodule(module);\n}\n</code></pre>"},{"location":"Development/adding_modules/#4-adding-module-to-initialization","title":"4. Adding Module to Initialization","text":"<p>Modules are initialized by the <code>Track</code> they belong to. First you have to include your module header in the file <code>Track/Track.h</code> like this: <code>#include &lt;MyModule.h&gt;</code>, then you have to add a case for your module in the Constructor of <code>Track</code> in the file <code>Track/Track.cpp</code>:</p> <pre><code>switch (module_config-&gt;module_type())\n        {\n            // MODULE SWITCH CASES GO HERE\n            ...\n            CASE_MODULE(Modules::MY_MODULE, MyModuleConfig, MyModule);\n            ...\n            // END MODULE SWITCH CASES\n        default:\n            break;\n        }\n</code></pre>"}]}